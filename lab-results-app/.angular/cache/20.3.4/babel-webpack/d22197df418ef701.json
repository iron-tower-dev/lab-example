{"ast":null,"code":"import { inject } from '@angular/core';\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\nimport { Observable, BehaviorSubject, combineLatest, of } from 'rxjs';\nimport { map, switchMap } from 'rxjs/operators';\nimport { ValidationService } from './validation.service';\nimport { UserQualificationService } from './user-qualification.service';\nimport { EquipmentService } from './equipment.service';\nimport { StatusManagementService } from './status-management.service';\nimport * as i0 from \"@angular/core\";\nexport let TestResultService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class TestResultService {\n    constructor() {\n      this.http = inject(HttpClient);\n      this.validationService = inject(ValidationService);\n      this.userQualificationService = inject(UserQualificationService);\n      this.equipmentService = inject(EquipmentService);\n      this.statusManagementService = inject(StatusManagementService);\n      this.apiUrl = 'https://localhost:7001/api';\n      this.currentEmployeeId = new BehaviorSubject('TEST001');\n      this.currentEmployeeId$ = this.currentEmployeeId.asObservable();\n    }\n    getHeaders() {\n      return new HttpHeaders({\n        'X-Employee-Id': this.currentEmployeeId.value,\n        'Content-Type': 'application/json'\n      });\n    }\n    setCurrentEmployee(employeeId) {\n      this.currentEmployeeId.next(employeeId);\n    }\n    getSampleInfo(sampleId) {\n      return this.http.get(`${this.apiUrl}/testresults/sample/${sampleId}`);\n    }\n    getTestInfo(testId) {\n      return this.http.get(`${this.apiUrl}/testresults/test/${testId}`);\n    }\n    getUserQualification(employeeId, testId) {\n      return this.http.get(`${this.apiUrl}/testresults/qualification/${employeeId}/${testId}`);\n    }\n    getTestResults(sampleId, testId) {\n      return this.http.get(`${this.apiUrl}/testresults/${sampleId}/${testId}`);\n    }\n    saveTestResults(saveData) {\n      return this.http.post(`${this.apiUrl}/testresults/save`, saveData, {\n        headers: this.getHeaders()\n      });\n    }\n    getEquipment(equipmentType, testId) {\n      const params = testId ? `?testId=${testId}` : '';\n      return this.http.get(`${this.apiUrl}/testresults/equipment/${equipmentType}${params}`);\n    }\n    getViscometers(lubeType, testId) {\n      return this.http.get(`${this.apiUrl}/testresults/equipment/viscometers?lubeType=${lubeType}&testId=${testId}`);\n    }\n    getComments(area) {\n      return this.http.get(`${this.apiUrl}/testresults/equipment/comments/${area}`);\n    }\n    getParticleTypes(sampleId, testId) {\n      return this.http.get(`${this.apiUrl}/particleanalysis/${sampleId}/${testId}`);\n    }\n    saveParticleTypes(sampleId, testId, particleTypes) {\n      return this.http.post(`${this.apiUrl}/particleanalysis/${sampleId}/${testId}`, particleTypes);\n    }\n    // Helper methods for business logic\n    canUserEnterResults(qualification) {\n      return qualification.canEnter;\n    }\n    canUserReviewResults(qualification) {\n      return qualification.canReview;\n    }\n    getTestDisplayName(test) {\n      return test.name || test.abbrev || test.shortAbbrev || `Test ${test.id}`;\n    }\n    formatEquipmentDisplay(equipment) {\n      return equipment.displayText || equipment.name;\n    }\n    isTestResultValid(entry, testId) {\n      // Implement validation logic based on test type\n      switch (testId) {\n        case 10:\n          // TAN\n          return !!(entry.value1 && entry.value3);\n        case 50:\n        case 60:\n          // Viscosity\n          return !!(entry.id1 && entry.id2 && entry.id3 && entry.value1);\n        case 70:\n          // FTIR\n          return true;\n        // FTIR has optional fields\n        case 120:\n        case 180:\n        case 210:\n        case 240:\n          // Particle Analysis\n          return !!entry.id1;\n        // Overall severity required\n        default:\n          return !!entry.value1;\n      }\n    }\n    calculateTANResult(sampleWeight, finalBuret) {\n      if (sampleWeight === 0) return 0;\n      const result = finalBuret * 5.61 / sampleWeight;\n      return Math.round(result * 100) / 100;\n    }\n    calculateViscosityResult(stopTime, calibration) {\n      return Math.round(calibration * stopTime * 100) / 100;\n    }\n    calculateFlashPointResult(pressure, flashPointTemp) {\n      const result = flashPointTemp + 0.06 * (760 - pressure);\n      return Math.round(result / 2) * 2;\n    }\n    calculateGreasePenetrationResult(cone1, cone2, cone3) {\n      const average = Math.round((cone1 + cone2 + cone3) / 3);\n      return average * 3.75 + 24;\n    }\n    calculateDroppingPointResult(droppingPoint, blockTemp) {\n      return Math.round(droppingPoint + (blockTemp - droppingPoint) / 3);\n    }\n    calculateFilterResidueResult(sampleSize, residueWeight) {\n      if (sampleSize === 0) return 0;\n      const result = 100 / sampleSize * residueWeight;\n      return Math.round(result * 10) / 10;\n    }\n    // Test-specific save methods\n    saveTanTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/tan`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    saveEmissionSpectroTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/emission-spectro`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    saveViscosityTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/viscosity`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    saveFtirTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/ftir`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    saveFlashPointTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/flash-point`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    saveParticleCountTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/particle-count`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    saveGreasePenetrationTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/grease-penetration`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    saveDroppingPointTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/dropping-point`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    saveRbotTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/rbot`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    saveOxidationStabilityTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/oxidation-stability`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    saveDeleteriousTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/deleterious`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    saveRheometerTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/rheometer`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    // Additional test-specific save methods\n    saveSimpleResultTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/simple-result`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    saveFilterInspectionTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/filter-inspection`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    saveFilterResidueTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/filter-residue`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    saveSimpleSelectTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/simple-select`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    saveRbotFailTimeTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/rbot-fail-time`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    saveInspectFilterTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/inspect-filter`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    saveDInchTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/d-inch`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    saveOilContentTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/oil-content`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    saveVarnishPotentialTest(dto) {\n      return this.http.post(`${this.apiUrl}/tests/varnish-potential`, dto, {\n        headers: this.getHeaders()\n      });\n    }\n    // Integration methods with validation, qualification, equipment, and status services\n    /**\n     * Validate test result with comprehensive validation\n     */\n    validateTestResult(testId, testData, isPartialSave = false) {\n      return new Observable(observer => {\n        const result = this.validationService.validateTestResult(testId, testData, isPartialSave);\n        observer.next(result);\n        observer.complete();\n      });\n    }\n    /**\n     * Check if current user is qualified for a test\n     */\n    isUserQualifiedForTest(testId) {\n      return this.userQualificationService.isUserQualified(this.currentEmployeeId.value, testId).pipe(map(qualification => qualification !== null));\n    }\n    /**\n     * Get user qualification level for a test\n     */\n    getUserQualificationForTest(testId) {\n      return this.userQualificationService.isUserQualified(this.currentEmployeeId.value, testId);\n    }\n    /**\n     * Check if user can perform an action\n     */\n    canUserPerformAction(testId, action, currentStatus = 'X') {\n      return combineLatest([this.getUserQualificationForTest(testId), this.statusManagementService.canPerformAction(action, currentStatus, testId, '')]).pipe(switchMap(([qualification, canPerform]) => {\n        if (!qualification) return of(false);\n        return this.statusManagementService.canPerformAction(action, currentStatus, testId, qualification);\n      }));\n    }\n    /**\n     * Get equipment for a test with validation\n     */\n    getEquipmentForTestWithValidation(testId, equipmentType) {\n      return this.equipmentService.getEquipmentByTypeAndTest(equipmentType, testId).pipe(map(equipment => equipment.filter(e => !e.isOverdue)));\n    }\n    /**\n     * Validate equipment selection\n     */\n    validateEquipmentSelection(equipName, testId, equipType) {\n      return this.equipmentService.validateEquipmentForTest(equipName, testId, equipType);\n    }\n    /**\n     * Get appropriate status for save operation\n     */\n    getSaveStatus(testId, isPartialSave) {\n      return this.getUserQualificationForTest(testId).pipe(switchMap(qualification => {\n        if (isPartialSave) {\n          return this.statusManagementService.getPartialSaveStatus(testId, qualification || '');\n        } else {\n          return this.statusManagementService.getFullSaveStatus(testId, qualification || '');\n        }\n      }));\n    }\n    /**\n     * Save test result with comprehensive validation and status management\n     */\n    saveTestResultWithValidation(testId, testData, isPartialSave = false) {\n      return combineLatest([this.validateTestResult(testId, testData, isPartialSave), this.isUserQualifiedForTest(testId), this.getSaveStatus(testId, isPartialSave)]).pipe(switchMap(([validationResult, isQualified, status]) => {\n        if (!validationResult.isValid) {\n          return of({\n            success: false,\n            message: 'Validation failed: ' + validationResult.errors.join(', '),\n            validationResult\n          });\n        }\n        if (!isQualified) {\n          return of({\n            success: false,\n            message: 'User is not qualified for this test'\n          });\n        }\n        // Add status to test data\n        const testDataWithStatus = {\n          ...testData,\n          status\n        };\n        // Save the test result\n        return this.saveTestResults({\n          sampleId: testData.sampleId,\n          testId: testId,\n          mode: 'entry',\n          entries: [{\n            sampleId: testData.sampleId,\n            testId: testId,\n            trialNumber: testData.trialNumber || 1,\n            value1: testData.value1,\n            value2: testData.value2,\n            value3: testData.value3,\n            id1: testData.id1,\n            id2: testData.id2,\n            id3: testData.id3,\n            status: status,\n            mainComments: testData.mainComments,\n            isPartialSave: isPartialSave,\n            isMediaReady: false,\n            isDelete: false\n          }],\n          isPartialSave: isPartialSave,\n          isMediaReady: false,\n          isDelete: false\n        }).pipe(map(response => ({\n          success: true,\n          message: 'Test result saved successfully',\n          validationResult\n        })));\n      }));\n    }\n    /**\n     * Get test workflow information\n     */\n    getTestWorkflowInfo(testId) {\n      return combineLatest([this.statusManagementService.getTestWorkflow(testId), this.statusManagementService.isPartialSaveAllowed(testId), this.statusManagementService.isDeleteAllowed(testId), this.statusManagementService.isReviewRequired(testId)]).pipe(map(([workflow, canPartialSave, canDelete, requiresReview]) => ({\n        workflow,\n        currentStatus: 'X',\n        // This would come from the actual test data\n        nextStatuses: [],\n        // This would be populated based on current status\n        canPartialSave,\n        canDelete,\n        requiresReview\n      })));\n    }\n    /**\n     * Get comprehensive test information including validation rules, equipment, and workflow\n     */\n    getComprehensiveTestInfo(testId) {\n      return combineLatest([this.getTestInfo(testId), this.equipmentService.getEquipmentTypesForTest(testId), this.statusManagementService.getTestWorkflow(testId), this.getUserQualificationForTest(testId)]).pipe(map(([testInfo, equipmentTypes, workflow, userQualification]) => ({\n        testInfo,\n        validationRules: this.validationService['validationRules'][testId] || {},\n        equipmentTypes,\n        workflow,\n        userQualification\n      })));\n    }\n    /**\n     * Get overdue equipment for current user's tests\n     */\n    getOverdueEquipmentForUser() {\n      return this.equipmentService.getOverdueEquipment();\n    }\n    /**\n     * Get tests pending review for current user\n     */\n    getTestsPendingReviewForUser() {\n      return this.statusManagementService.getTestsPendingReview();\n    }\n    /**\n     * Get user's qualification summary\n     */\n    getUserQualificationSummary() {\n      return combineLatest([this.userQualificationService.getHighestQualificationLevel(this.currentEmployeeId.value), this.userQualificationService.isSupervisor(this.currentEmployeeId.value), this.userQualificationService.getUserQualifications(this.currentEmployeeId.value)]).pipe(map(([highestLevel, isSupervisor, qualifications]) => ({\n        highestLevel,\n        isSupervisor,\n        qualifications\n      })));\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function TestResultService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || TestResultService)();\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: TestResultService,\n      factory: TestResultService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return TestResultService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}