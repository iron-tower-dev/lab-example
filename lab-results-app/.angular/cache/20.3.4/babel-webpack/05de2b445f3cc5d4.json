{"ast":null,"code":"import { inject } from '@angular/core';\nimport { TestResultService } from './test-result.service';\nimport * as i0 from \"@angular/core\";\nexport let ValidationService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class ValidationService {\n    constructor() {\n      this.testResultService = inject(TestResultService);\n      // Test-specific validation rules\n      this.validationRules = {\n        10: {\n          requiredFields: ['sampleWeight', 'finalBuret'],\n          numericRanges: {\n            sampleWeight: {\n              min: 0.1,\n              max: 100\n            },\n            finalBuret: {\n              min: 0,\n              max: 50\n            }\n          },\n          customValidations: {\n            sampleWeight: this.positiveNumberValidator(),\n            finalBuret: this.positiveNumberValidator()\n          },\n          businessRules: ['Sample weight must be greater than 0', 'Final buret reading must be non-negative', 'TAN result must be calculated and within acceptable range (0.01 - 100)']\n        },\n        30: {\n          requiredFields: ['trialNumber'],\n          numericRanges: {\n            Na: {\n              min: 0,\n              max: 10000\n            },\n            Mo: {\n              min: 0,\n              max: 10000\n            },\n            Mg: {\n              min: 0,\n              max: 10000\n            },\n            P: {\n              min: 0,\n              max: 10000\n            },\n            B: {\n              min: 0,\n              max: 10000\n            },\n            H: {\n              min: 0,\n              max: 10000\n            },\n            Cr: {\n              min: 0,\n              max: 10000\n            },\n            Ca: {\n              min: 0,\n              max: 10000\n            },\n            Ni: {\n              min: 0,\n              max: 10000\n            },\n            Ag: {\n              min: 0,\n              max: 10000\n            },\n            Cu: {\n              min: 0,\n              max: 10000\n            },\n            Sn: {\n              min: 0,\n              max: 10000\n            },\n            Al: {\n              min: 0,\n              max: 10000\n            },\n            Mn: {\n              min: 0,\n              max: 10000\n            },\n            Pb: {\n              min: 0,\n              max: 10000\n            },\n            Fe: {\n              min: 0,\n              max: 10000\n            },\n            Si: {\n              min: 0,\n              max: 10000\n            },\n            Ba: {\n              min: 0,\n              max: 10000\n            },\n            Sb: {\n              min: 0,\n              max: 10000\n            },\n            Zn: {\n              min: 0,\n              max: 10000\n            }\n          },\n          customValidations: {},\n          businessRules: ['At least one element must have a value', 'All element values must be non-negative', 'Element values should be within typical PPM ranges']\n        },\n        40: {\n          requiredFields: ['trialNumber'],\n          numericRanges: {\n            Na: {\n              min: 0,\n              max: 10000\n            },\n            Mo: {\n              min: 0,\n              max: 10000\n            },\n            Mg: {\n              min: 0,\n              max: 10000\n            },\n            P: {\n              min: 0,\n              max: 10000\n            },\n            B: {\n              min: 0,\n              max: 10000\n            },\n            H: {\n              min: 0,\n              max: 10000\n            },\n            Cr: {\n              min: 0,\n              max: 10000\n            },\n            Ca: {\n              min: 0,\n              max: 10000\n            },\n            Ni: {\n              min: 0,\n              max: 10000\n            },\n            Ag: {\n              min: 0,\n              max: 10000\n            },\n            Cu: {\n              min: 0,\n              max: 10000\n            },\n            Sn: {\n              min: 0,\n              max: 10000\n            },\n            Al: {\n              min: 0,\n              max: 10000\n            },\n            Mn: {\n              min: 0,\n              max: 10000\n            },\n            Pb: {\n              min: 0,\n              max: 10000\n            },\n            Fe: {\n              min: 0,\n              max: 10000\n            },\n            Si: {\n              min: 0,\n              max: 10000\n            },\n            Ba: {\n              min: 0,\n              max: 10000\n            },\n            Sb: {\n              min: 0,\n              max: 10000\n            },\n            Zn: {\n              min: 0,\n              max: 10000\n            }\n          },\n          customValidations: {},\n          businessRules: ['At least one element must have a value', 'All element values must be non-negative', 'Element values should be within typical PPM ranges']\n        },\n        50: {\n          requiredFields: ['stopWatchTime', 'viscometerId'],\n          numericRanges: {\n            stopWatchTime: {\n              min: 200,\n              max: 3600\n            }\n          },\n          customValidations: {\n            stopWatchTime: this.viscosityTimeValidator(),\n            viscometerId: this.requiredValidator()\n          },\n          businessRules: ['Stop watch time must be greater than 200 seconds', 'Viscometer must be selected', 'For Q/QAG samples, two trials are required', 'Repeatability between trials must be within 0.35%']\n        },\n        60: {\n          requiredFields: ['stopWatchTime', 'viscometerId'],\n          numericRanges: {\n            stopWatchTime: {\n              min: 200,\n              max: 3600\n            }\n          },\n          customValidations: {\n            stopWatchTime: this.viscosityTimeValidator(),\n            viscometerId: this.requiredValidator()\n          },\n          businessRules: ['Stop watch time must be greater than 200 seconds', 'Viscometer must be selected', 'For Q/QAG samples, two trials are required', 'Repeatability between trials must be within 0.35%']\n        },\n        70: {\n          requiredFields: ['trialNumber'],\n          numericRanges: {\n            deltaArea: {\n              min: 0,\n              max: 100\n            },\n            antiOxidant: {\n              min: 0,\n              max: 100\n            },\n            oxidation: {\n              min: 0,\n              max: 100\n            },\n            h2o: {\n              min: 0,\n              max: 100\n            },\n            antiWear: {\n              min: 0,\n              max: 100\n            },\n            soot: {\n              min: 0,\n              max: 100\n            },\n            fuelDilution: {\n              min: 0,\n              max: 100\n            },\n            mixture: {\n              min: 0,\n              max: 100\n            },\n            weakAcid: {\n              min: 0,\n              max: 100\n            }\n          },\n          customValidations: {},\n          businessRules: ['At least one FTIR parameter must have a value', 'All parameter values must be non-negative', 'Parameter values should be within 0-100 range']\n        },\n        80: {\n          requiredFields: ['barometricPressure', 'flashPointTemperature'],\n          numericRanges: {\n            barometricPressure: {\n              min: 700,\n              max: 800\n            },\n            flashPointTemperature: {\n              min: 50,\n              max: 500\n            }\n          },\n          customValidations: {\n            barometricPressure: this.barometricPressureValidator(),\n            flashPointTemperature: this.temperatureValidator()\n          },\n          businessRules: ['Barometric pressure must be within 700-800 mm Hg', 'Flash point temperature must be reasonable for the sample type', 'Corrected flash point will be calculated automatically']\n        },\n        110: {\n          requiredFields: ['result'],\n          numericRanges: {\n            result: {\n              min: 0,\n              max: 999999\n            }\n          },\n          customValidations: {\n            result: this.positiveNumberValidator()\n          },\n          businessRules: ['Result must be a positive number', 'Result should be within reasonable range for the test type']\n        },\n        120: {\n          requiredFields: ['overallSeverity'],\n          numericRanges: {\n            overallSeverity: {\n              min: 1,\n              max: 4\n            }\n          },\n          customValidations: {\n            overallSeverity: this.severityValidator()\n          },\n          businessRules: ['Overall severity must be selected (1-4)', 'At least one particle type must be characterized', 'All characterized particle types must have complete evaluations', 'Comments are required for characterized particle types']\n        },\n        130: {\n          requiredFields: ['firstPenetration', 'secondPenetration', 'thirdPenetration'],\n          numericRanges: {\n            firstPenetration: {\n              min: 0,\n              max: 1000\n            },\n            secondPenetration: {\n              min: 0,\n              max: 1000\n            },\n            thirdPenetration: {\n              min: 0,\n              max: 1000\n            }\n          },\n          customValidations: {\n            firstPenetration: this.penetrationValidator(),\n            secondPenetration: this.penetrationValidator(),\n            thirdPenetration: this.penetrationValidator()\n          },\n          businessRules: ['All three penetration values are required', 'Penetration values must be within 0-1000 range', 'NLGI grade will be calculated from average penetration', 'Penetration values should be consistent']\n        },\n        140: {\n          requiredFields: ['droppingPointTemperature', 'blockTemperature'],\n          numericRanges: {\n            droppingPointTemperature: {\n              min: 50,\n              max: 400\n            },\n            blockTemperature: {\n              min: 50,\n              max: 400\n            }\n          },\n          customValidations: {\n            droppingPointTemperature: this.temperatureValidator(),\n            blockTemperature: this.temperatureValidator()\n          },\n          businessRules: ['Dropping point and block temperatures are required', 'Temperatures must be within reasonable range', 'Dropping point and block thermometers cannot be the same', 'Corrected dropping point will be calculated']\n        },\n        160: {\n          requiredFields: ['trialNumber'],\n          numericRanges: {\n            micron5_10: {\n              min: 0,\n              max: 1000000\n            },\n            micron10_15: {\n              min: 0,\n              max: 1000000\n            },\n            micron15_25: {\n              min: 0,\n              max: 1000000\n            },\n            micron25_50: {\n              min: 0,\n              max: 1000000\n            },\n            micron50_100: {\n              min: 0,\n              max: 1000000\n            },\n            micron100: {\n              min: 0,\n              max: 1000000\n            }\n          },\n          customValidations: {},\n          businessRules: ['At least one particle count range must have a value', 'All particle counts must be non-negative', 'ISO code and NAS class will be calculated automatically']\n        },\n        170: {\n          requiredFields: ['failTime'],\n          numericRanges: {\n            failTime: {\n              min: 0,\n              max: 10000\n            }\n          },\n          customValidations: {\n            failTime: this.positiveNumberValidator()\n          },\n          businessRules: ['Fail time is required', 'Fail time must be a positive number', 'Fail time should be within reasonable range for RBOT test']\n        },\n        180: {\n          requiredFields: ['sampleSize', 'residueWeight', 'overallSeverity'],\n          numericRanges: {\n            sampleSize: {\n              min: 0.1,\n              max: 1000\n            },\n            residueWeight: {\n              min: 0,\n              max: 1000\n            },\n            overallSeverity: {\n              min: 1,\n              max: 4\n            }\n          },\n          customValidations: {\n            sampleSize: this.positiveNumberValidator(),\n            residueWeight: this.nonNegativeNumberValidator(),\n            overallSeverity: this.severityValidator()\n          },\n          businessRules: ['Sample size and residue weight are required', 'Sample size must be greater than 0', 'Residue weight must be non-negative', 'Overall severity must be selected', 'At least one particle type must be characterized']\n        },\n        210: {\n          requiredFields: ['overallSeverity', 'dilutionFactor'],\n          numericRanges: {\n            overallSeverity: {\n              min: 1,\n              max: 4\n            }\n          },\n          customValidations: {\n            overallSeverity: this.severityValidator(),\n            dilutionFactor: this.requiredValidator()\n          },\n          businessRules: ['Overall severity must be selected', 'Dilution factor must be specified', 'At least one particle type must be characterized', 'All characterized particle types must have complete evaluations']\n        },\n        220: {\n          requiredFields: ['passFailResult'],\n          numericRanges: {},\n          customValidations: {\n            passFailResult: this.passFailValidator()\n          },\n          businessRules: ['Pass/Fail result must be selected', 'For Q/QAG samples, recheck is required if any failures occur']\n        },\n        230: {\n          requiredFields: ['failTime'],\n          numericRanges: {\n            failTime: {\n              min: 0,\n              max: 10000\n            }\n          },\n          customValidations: {\n            failTime: this.positiveNumberValidator()\n          },\n          businessRules: ['Fail time is required', 'Fail time must be a positive number']\n        },\n        240: {\n          requiredFields: ['overallSeverity', 'volumeOfOil'],\n          numericRanges: {\n            overallSeverity: {\n              min: 1,\n              max: 4\n            }\n          },\n          customValidations: {\n            overallSeverity: this.severityValidator(),\n            volumeOfOil: this.requiredValidator()\n          },\n          businessRules: ['Overall severity must be selected', 'Volume of oil used must be specified', 'At least one particle type must be characterized']\n        },\n        250: {\n          requiredFields: ['pressure', 'scratches', 'passFail'],\n          numericRanges: {\n            pressure: {\n              min: 0,\n              max: 10000\n            },\n            scratches: {\n              min: 0,\n              max: 100\n            }\n          },\n          customValidations: {\n            pressure: this.nonNegativeNumberValidator(),\n            scratches: this.nonNegativeNumberValidator(),\n            passFail: this.passFailValidator()\n          },\n          businessRules: ['Pressure and scratches values are required', 'Pass/Fail result must be selected', 'Values must be non-negative']\n        },\n        270: {\n          requiredFields: ['testResult'],\n          numericRanges: {},\n          customValidations: {\n            testResult: this.requiredValidator()\n          },\n          businessRules: ['Test result must be selected']\n        },\n        284: {\n          requiredFields: ['dInch'],\n          numericRanges: {\n            dInch: {\n              min: 0,\n              max: 100\n            }\n          },\n          customValidations: {\n            dInch: this.positiveNumberValidator()\n          },\n          businessRules: ['D-inch value is required', 'D-inch must be a positive number']\n        },\n        285: {\n          requiredFields: ['oilContent'],\n          numericRanges: {\n            oilContent: {\n              min: 0,\n              max: 100\n            }\n          },\n          customValidations: {\n            oilContent: this.positiveNumberValidator()\n          },\n          businessRules: ['Oil content value is required', 'Oil content must be a positive number']\n        },\n        286: {\n          requiredFields: ['varnishPotentialRating'],\n          numericRanges: {\n            varnishPotentialRating: {\n              min: 0,\n              max: 100\n            }\n          },\n          customValidations: {\n            varnishPotentialRating: this.positiveNumberValidator()\n          },\n          businessRules: ['Varnish potential rating is required', 'Rating must be a positive number']\n        }\n      };\n    }\n    /**\n     * Validates a test result based on the test type\n     */\n    validateTestResult(testId, testData, isPartialSave = false, qualityClass = '') {\n      const rules = this.validationRules[testId];\n      if (!rules) {\n        return {\n          isValid: false,\n          errors: [`No validation rules found for test ID ${testId}`],\n          warnings: []\n        };\n      }\n      const errors = [];\n      const warnings = [];\n      // 1. Validate required fields\n      const requiredFieldsResult = this.validateRequiredFields(testId, testData, isPartialSave);\n      errors.push(...requiredFieldsResult.errors);\n      warnings.push(...requiredFieldsResult.warnings);\n      // 2. Check numeric ranges\n      for (const [field, range] of Object.entries(rules.numericRanges)) {\n        const value = testData[field];\n        if (value !== null && value !== undefined && value !== '') {\n          const numValue = Number(value);\n          if (isNaN(numValue)) {\n            errors.push(`${this.getFieldDisplayName(field)} must be a valid number`);\n          } else {\n            if (numValue < range.min) {\n              errors.push(`${this.getFieldDisplayName(field)} must be at least ${range.min}`);\n            }\n            if (numValue > range.max) {\n              errors.push(`${this.getFieldDisplayName(field)} must not exceed ${range.max}`);\n            }\n          }\n        }\n      }\n      // 3. Apply custom validations\n      for (const [field, validator] of Object.entries(rules.customValidations)) {\n        const control = {\n          value: testData[field]\n        };\n        const validationResult = validator(control);\n        if (validationResult) {\n          for (const [errorKey, errorMessage] of Object.entries(validationResult)) {\n            errors.push(`${this.getFieldDisplayName(field)}: ${errorMessage}`);\n          }\n        }\n      }\n      // 4. Validate test selection (at least one trial must be selected)\n      const testSelectionResult = this.validateTestSelection(testData, testId);\n      errors.push(...testSelectionResult.errors);\n      warnings.push(...testSelectionResult.warnings);\n      // 5. Apply test-specific business rules\n      const businessRulesResult = this.validateTestSpecificRules(testId, testData, qualityClass, isPartialSave);\n      errors.push(...businessRulesResult.errors);\n      warnings.push(...businessRulesResult.warnings);\n      // 6. Validate repeatability for multi-trial tests\n      if (testData.trials && Array.isArray(testData.trials)) {\n        const repeatabilityResult = this.validateRepeatability(testData.trials, testId, qualityClass);\n        errors.push(...repeatabilityResult.errors);\n        warnings.push(...repeatabilityResult.warnings);\n      }\n      // 7. Validate particle types for tests that require them\n      if (testData.particleTypes && Array.isArray(testData.particleTypes)) {\n        const particleValidationResult = this.validateParticleTypes(testData.particleTypes, testId);\n        errors.push(...particleValidationResult.errors);\n        warnings.push(...particleValidationResult.warnings);\n      }\n      return {\n        isValid: errors.length === 0,\n        errors,\n        warnings\n      };\n    }\n    /**\n     * Validates particle types for tests that require them\n     */\n    validateParticleTypes(particleTypes, testId) {\n      const errors = [];\n      const warnings = [];\n      if (!particleTypes || particleTypes.length === 0) {\n        errors.push('At least one particle type must be characterized');\n        return {\n          isValid: false,\n          errors,\n          warnings\n        };\n      }\n      const characterizedTypes = particleTypes.filter(pt => pt.status === '1');\n      if (characterizedTypes.length === 0) {\n        errors.push('At least one particle type must be set to \"Review\" status');\n        return {\n          isValid: false,\n          errors,\n          warnings\n        };\n      }\n      // Validate each characterized particle type\n      for (const particleType of characterizedTypes) {\n        const missingFields = [];\n        if (!particleType.heat) missingFields.push('Heat');\n        if (!particleType.concentration) missingFields.push('Concentration');\n        if (!particleType.sizeAve) missingFields.push('Size, Ave');\n        if (!particleType.sizeMax) missingFields.push('Size, Max');\n        if (!particleType.color) missingFields.push('Color');\n        if (!particleType.texture) missingFields.push('Texture');\n        if (!particleType.composition) missingFields.push('Composition');\n        if (!particleType.severity) missingFields.push('Severity');\n        if (missingFields.length > 0) {\n          errors.push(`Particle type ${particleType.particleTypeDefinitionId}: Missing ${missingFields.join(', ')}`);\n        }\n      }\n      return {\n        isValid: errors.length === 0,\n        errors,\n        warnings\n      };\n    }\n    /**\n     * Validates equipment selection\n     */\n    validateEquipment(equipmentId, equipmentType, testId) {\n      const errors = [];\n      const warnings = [];\n      if (!equipmentId) {\n        errors.push(`${equipmentType} selection is required`);\n        return {\n          isValid: false,\n          errors,\n          warnings\n        };\n      }\n      // Check if equipment is overdue (this would typically come from the service)\n      // For now, we'll add a placeholder for this validation\n      warnings.push('Equipment validation requires service integration');\n      return {\n        isValid: errors.length === 0,\n        errors,\n        warnings\n      };\n    }\n    /**\n     * Validates user qualifications for a specific test\n     */\n    validateUserQualification(userId, testId) {\n      const errors = [];\n      const warnings = [];\n      if (!userId) {\n        errors.push('User ID is required');\n        return {\n          isValid: false,\n          errors,\n          warnings\n        };\n      }\n      // This would typically check against the LubeTechQualification table\n      // For now, we'll add a placeholder\n      warnings.push('User qualification validation requires service integration');\n      return {\n        isValid: true,\n        errors,\n        warnings\n      };\n    }\n    /**\n     * Validates repeatability for tests that require multiple trials\n     */\n    validateRepeatability(trials, testId, qualityClass) {\n      const errors = [];\n      const warnings = [];\n      if (testId === 50 || testId === 60) {\n        // Viscosity tests\n        if (qualityClass === 'Q' || qualityClass === 'QAG') {\n          if (trials.length < 2) {\n            errors.push('Two trials are required for Q/QAG samples');\n            return {\n              isValid: false,\n              errors,\n              warnings\n            };\n          }\n          // Check repeatability\n          const values = trials.map(trial => trial.calculatedResult || trial.value3).filter(v => v > 0);\n          if (values.length >= 2) {\n            const max = Math.max(...values);\n            const min = Math.min(...values);\n            const repeatability = (max - min) / max * 100;\n            if (repeatability > 0.35) {\n              errors.push(`Repeatability is ${repeatability.toFixed(2)}%, which exceeds the 0.35% limit`);\n            }\n          }\n        }\n      }\n      return {\n        isValid: errors.length === 0,\n        errors,\n        warnings\n      };\n    }\n    /**\n     * Validates test-specific business rules from VB application\n     */\n    validateTestSpecificRules(testId, testData, qualityClass, isPartialSave = false) {\n      const errors = [];\n      const warnings = [];\n      switch (testId) {\n        case 10:\n          // TAN Test\n          if (testData.sampleWeight && testData.finalBuret) {\n            const tanResult = testData.finalBuret * 5.61 / testData.sampleWeight * 100;\n            if (tanResult < 0.01) {\n              warnings.push('Calculated TAN result is very low (< 0.01)');\n            }\n            if (tanResult > 100) {\n              warnings.push('Calculated TAN result is very high (> 100)');\n            }\n          }\n          break;\n        case 50:\n        case 60:\n          // Viscosity tests\n          if (testData.stopWatchTime && testData.stopWatchTime <= 200) {\n            errors.push('Stop watch time must be greater than 200 seconds');\n          }\n          // Q/QAG samples require two trials\n          if ((qualityClass === 'Q' || qualityClass === 'QAG') && !isPartialSave) {\n            if (!testData.trial2 || !testData.trial2.stopWatchTime) {\n              errors.push('Two trials are required for Q/QAG samples');\n            }\n          }\n          break;\n        case 70:\n          // FTIR\n          // Check if any data has been entered\n          const hasData = Object.values(testData).some(value => value !== null && value !== undefined && value !== '' && value !== 0);\n          if (!hasData && !isPartialSave) {\n            warnings.push('No FTIR data has been entered. Are you sure you want to save?');\n          }\n          break;\n        case 80:\n          // Flash Point\n          if (testData.barometricPressure && testData.flashPointTemperature) {\n            const correctedFP = testData.flashPointTemperature + 0.06 * (760 - testData.barometricPressure);\n            testData.correctedFlashPoint = Math.round(correctedFP / 2) * 2;\n          }\n          break;\n        case 120: // Filter Inspection\n        case 180: // Filter Residue\n        case 210: // Ferrogram\n        case 240:\n          // Inspect Filter\n          // Overall severity must be selected\n          if (!testData.overallSeverity) {\n            errors.push('Please select Overall Severity');\n          }\n          // At least one particle type must be characterized\n          if (!testData.particleTypes || testData.particleTypes.length === 0) {\n            errors.push('At least 1 particle type should be characterized');\n          } else {\n            const characterizedTypes = testData.particleTypes.filter(pt => pt.status === '1');\n            if (characterizedTypes.length === 0) {\n              errors.push('At least 1 particle type should be characterized');\n            }\n            // Validate each characterized particle type\n            for (const particleType of characterizedTypes) {\n              const missingFields = [];\n              if (!particleType.heat) missingFields.push('Heat');\n              if (!particleType.concentration) missingFields.push('Concentration');\n              if (!particleType.sizeAve) missingFields.push('Size, Ave');\n              if (!particleType.sizeMax) missingFields.push('Size, Max');\n              if (!particleType.color) missingFields.push('Color');\n              if (!particleType.texture) missingFields.push('Texture');\n              if (!particleType.composition) missingFields.push('Composition');\n              if (!particleType.severity) missingFields.push('Severity');\n              if (missingFields.length > 0) {\n                errors.push(`Particle type ${particleType.type}: Missing ${missingFields.join(', ')}`);\n              }\n            }\n          }\n          // Comment length validation\n          if (testData.mainComments && testData.mainComments.length > 1000) {\n            errors.push('Too many characters in Comments, please correct!');\n          }\n          break;\n        case 130:\n          // Grease Penetration Worked\n          if (testData.firstPenetration && testData.secondPenetration && testData.thirdPenetration) {\n            const average = Math.round((testData.firstPenetration + testData.secondPenetration + testData.thirdPenetration) / 3);\n            testData.calculatedResult = average * 3.75 + 24;\n          }\n          break;\n        case 140:\n          // Dropping Point\n          if (testData.droppingPointTemperature && testData.blockTemperature) {\n            if (testData.droppingPointTemperature === testData.blockTemperature) {\n              errors.push('The dropping point and the block thermometers cannot be the same');\n            }\n            // Calculate corrected dropping point\n            testData.correctedDroppingPoint = Math.round(testData.droppingPointTemperature + (testData.blockTemperature - testData.droppingPointTemperature) / 3);\n          }\n          break;\n        case 180:\n          // Filter Residue\n          if (!isPartialSave) {\n            if (!testData.sampleSize || !testData.residueWeight) {\n              errors.push('Please enter Sample Size and Residue Weight');\n            }\n          }\n          if (testData.sampleSize && testData.residueWeight) {\n            if (testData.sampleSize <= 0) {\n              errors.push('Sample size must be greater than 0');\n            }\n            // Calculate percentage\n            testData.percentage = testData.sampleSize > 0 ? Math.round(100 / testData.sampleSize * testData.residueWeight * 10) / 10 : 0;\n          }\n          break;\n        case 220:\n          // Oxidation Stability\n          if (testData.passFailResult === 'fail' && !isPartialSave) {\n            warnings.push('Test failed - recheck may be required');\n          }\n          break;\n        case 240:\n          // Inspect Filter\n          if (!isPartialSave) {\n            if (!testData.volumeOfOilUsed) {\n              errors.push('Please enter Volume of Oil Used');\n            }\n          }\n          break;\n        case 250:\n          // Deleterious\n          if (testData.pressure && testData.scratches) {\n            if (testData.pressure < 0 || testData.scratches < 0) {\n              errors.push('Pressure and scratches values must be non-negative');\n            }\n          }\n          break;\n        case 270:\n          // Simple Select\n          if (!testData.testResult) {\n            errors.push('Test result must be selected');\n          }\n          break;\n      }\n      return {\n        isValid: errors.length === 0,\n        errors,\n        warnings\n      };\n    }\n    /**\n     * Validates that at least one test trial is selected for saving\n     */\n    validateTestSelection(testData, testId) {\n      const errors = [];\n      const warnings = [];\n      // Check if any trial is selected for saving\n      const hasSelectedTrial = Object.keys(testData).some(key => key.startsWith('trial') && testData[key] && testData[key].isSelected);\n      if (!hasSelectedTrial) {\n        errors.push('Please ensure that you have checked a test to save');\n      }\n      return {\n        isValid: errors.length === 0,\n        errors,\n        warnings\n      };\n    }\n    /**\n     * Validates required fields for specific test types\n     */\n    validateRequiredFields(testId, testData, isPartialSave = false) {\n      const errors = [];\n      const warnings = [];\n      // Get validation rules for this test\n      const rules = this.validationRules[testId];\n      if (!rules) {\n        return {\n          isValid: true,\n          errors,\n          warnings\n        };\n      }\n      // Check required fields\n      for (const field of rules.requiredFields) {\n        if (!testData[field] && testData[field] !== 0) {\n          errors.push(`${this.getFieldDisplayName(field)} is required`);\n        }\n      }\n      // Test-specific required field validations\n      switch (testId) {\n        case 180:\n          // Filter Residue\n          if (!isPartialSave) {\n            if (!testData.sampleSize || !testData.residueWeight) {\n              errors.push('Sample Size and Residue Weight are required');\n            }\n          }\n          break;\n        case 240:\n          // Inspect Filter\n          if (!isPartialSave) {\n            if (!testData.volumeOfOilUsed) {\n              errors.push('Volume of Oil Used is required');\n            }\n          }\n          break;\n      }\n      return {\n        isValid: errors.length === 0,\n        errors,\n        warnings\n      };\n    }\n    // Custom validators\n    positiveNumberValidator() {\n      return control => {\n        const value = control.value;\n        if (value === null || value === undefined || value === '') {\n          return null; // Let required validator handle empty values\n        }\n        const num = Number(value);\n        if (isNaN(num) || num <= 0) {\n          return {\n            positiveNumber: 'Value must be a positive number'\n          };\n        }\n        return null;\n      };\n    }\n    nonNegativeNumberValidator() {\n      return control => {\n        const value = control.value;\n        if (value === null || value === undefined || value === '') {\n          return null; // Let required validator handle empty values\n        }\n        const num = Number(value);\n        if (isNaN(num) || num < 0) {\n          return {\n            nonNegativeNumber: 'Value must be a non-negative number'\n          };\n        }\n        return null;\n      };\n    }\n    requiredValidator() {\n      return control => {\n        const value = control.value;\n        if (value === null || value === undefined || value === '') {\n          return {\n            required: 'This field is required'\n          };\n        }\n        return null;\n      };\n    }\n    viscosityTimeValidator() {\n      return control => {\n        const value = control.value;\n        if (value === null || value === undefined || value === '') {\n          return null; // Let required validator handle empty values\n        }\n        const num = Number(value);\n        if (isNaN(num)) {\n          return {\n            invalidNumber: 'Value must be a valid number'\n          };\n        }\n        if (num <= 200) {\n          return {\n            minTime: 'Stop watch time must be greater than 200 seconds'\n          };\n        }\n        return null;\n      };\n    }\n    barometricPressureValidator() {\n      return control => {\n        const value = control.value;\n        if (value === null || value === undefined || value === '') {\n          return null; // Let required validator handle empty values\n        }\n        const num = Number(value);\n        if (isNaN(num)) {\n          return {\n            invalidNumber: 'Value must be a valid number'\n          };\n        }\n        if (num < 700 || num > 800) {\n          return {\n            pressureRange: 'Barometric pressure must be between 700-800 mm Hg'\n          };\n        }\n        return null;\n      };\n    }\n    temperatureValidator() {\n      return control => {\n        const value = control.value;\n        if (value === null || value === undefined || value === '') {\n          return null; // Let required validator handle empty values\n        }\n        const num = Number(value);\n        if (isNaN(num)) {\n          return {\n            invalidNumber: 'Value must be a valid number'\n          };\n        }\n        if (num < 0 || num > 1000) {\n          return {\n            temperatureRange: 'Temperature must be between 0-1000°F'\n          };\n        }\n        return null;\n      };\n    }\n    penetrationValidator() {\n      return control => {\n        const value = control.value;\n        if (value === null || value === undefined || value === '') {\n          return null; // Let required validator handle empty values\n        }\n        const num = Number(value);\n        if (isNaN(num)) {\n          return {\n            invalidNumber: 'Value must be a valid number'\n          };\n        }\n        if (num < 0 || num > 1000) {\n          return {\n            penetrationRange: 'Penetration must be between 0-1000'\n          };\n        }\n        return null;\n      };\n    }\n    severityValidator() {\n      return control => {\n        const value = control.value;\n        if (value === null || value === undefined || value === '') {\n          return null; // Let required validator handle empty values\n        }\n        const num = Number(value);\n        if (isNaN(num) || num < 1 || num > 4) {\n          return {\n            severityRange: 'Severity must be between 1-4'\n          };\n        }\n        return null;\n      };\n    }\n    passFailValidator() {\n      return control => {\n        const value = control.value;\n        if (value === null || value === undefined || value === '') {\n          return null; // Let required validator handle empty values\n        }\n        if (value !== 'pass' && value !== 'fail') {\n          return {\n            passFail: 'Value must be either \"pass\" or \"fail\"'\n          };\n        }\n        return null;\n      };\n    }\n    getFieldDisplayName(field) {\n      const fieldNames = {\n        sampleWeight: 'Sample Weight',\n        finalBuret: 'Final Buret',\n        stopWatchTime: 'Stop Watch Time',\n        viscometerId: 'Viscometer',\n        thermometerMteId: 'Thermometer',\n        barometricPressure: 'Barometric Pressure',\n        flashPointTemperature: 'Flash Point Temperature',\n        overallSeverity: 'Overall Severity',\n        firstPenetration: 'First Penetration',\n        secondPenetration: 'Second Penetration',\n        thirdPenetration: 'Third Penetration',\n        droppingPointTemperature: 'Dropping Point Temperature',\n        blockTemperature: 'Block Temperature',\n        failTime: 'Fail Time',\n        sampleSize: 'Sample Size',\n        residueWeight: 'Residue Weight',\n        dilutionFactor: 'Dilution Factor',\n        passFailResult: 'Pass/Fail Result',\n        pressure: 'Pressure',\n        scratches: 'Scratches',\n        testResult: 'Test Result',\n        dInch: 'D-inch',\n        oilContent: 'Oil Content',\n        varnishPotentialRating: 'Varnish Potential Rating',\n        volumeOfOil: 'Volume of Oil'\n      };\n      return fieldNames[field] || field;\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function ValidationService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ValidationService)();\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: ValidationService,\n      factory: ValidationService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return ValidationService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}